import uuid
import enum
from datetime import datetime, UTC
from typing import Any, Dict, Optional, List, TYPE_CHECKING 

from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy import ForeignKey, Enum, DateTime, String
from sqlalchemy.dialects.postgresql import UUID, JSONB  
from app.db.models.base import Base # ✅ Corrected Base import path

# 💡 CRITICAL FIX: The previous fix caused a circular import.
if TYPE_CHECKING:
    from .user_model import User
    from .task_result_model import TaskResult 
    from .artifact_model import Artifact 

class JobStatus(str, enum.Enum):
    """
    Defines the possible states for a major asynchronous job.
    """
    PENDING = "PENDING"
    PROCESSING = "PROCESSING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"


# =========================================================================
# 📝 JOB ORM MODEL
# =========================================================================
class Job(Base):
    """
    Model for a main processing job initiated by a user.
    """

    __tablename__ = "jobs"
    __allow_unmapped__ = False # Added for consistency

    # --- Primary Key & Foreign Keys ---
    
    # Primary Key
    job_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
        doc="Unique UUID for this job.",
    )

    # 🔗 Foreign Key to User (One User has many Jobs)
    user_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("users.id", ondelete="CASCADE"),
        doc="The user who initiated this job.",
    )

    # --- Status and Metadata Fields ---
    
    status: Mapped[JobStatus] = mapped_column(
        Enum(JobStatus),
        default=JobStatus.PENDING,
        doc="Current state of the job.",
    )

    # 🎯 Input Data Field
    input_data: Mapped[Dict[str, Any]] = mapped_column(
        JSONB,  # Use PostgreSQL JSONB type for the input dictionary
        doc="The structured input payload for the Celery task.",
    )

    # 🎯 Task Path/Function Name (e.g., 'app.tasks.process_data')
    celery_task_name: Mapped[str] = mapped_column( 
        String(255),
        doc="The path to the Celery task function to be executed.",
    )
    
    name: Mapped[str] = mapped_column(
        String(255),
        doc="Human-readable name for the job.",
    )

    # --- Timestamps ---
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        default=datetime.now(UTC),
        doc="When the job was created.",
    )
    
    updated_at: Mapped[datetime] = mapped_column(
    DateTime(timezone=True),
    default=datetime.now(UTC),
    onupdate=datetime.now(UTC), 
    doc="When the job was last updated.",
    )

    finished_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
        doc="When the job hit a terminal status (COMPLETED/FAILED/CANCELLED).",
    )

    # --- Relationships ---

    # Link back to the User (Many-to-One)
    user: Mapped["User"] = relationship(back_populates="jobs")

    # Link to TaskResults (One-to-Many)
    task_results: Mapped[List["TaskResult"]] = relationship(
        "TaskResult", 
        back_populates="job",
        cascade="all, delete-orphan",
        doc="Individual task results associated with this job."
    )
    
    # Link to Artifacts (One-to-Many - assuming Artifact has job_id FK)
    artifacts: Mapped[List["Artifact"]] = relationship(
        "Artifact",
        back_populates="job",
        cascade="all, delete-orphan",
        doc="Output files/artifacts generated by this job."
    )


    def __repr__(self) -> str:
        return f"<Job(job_id='{self.job_id}', name='{self.name}', status='{self.status.value}')>"
