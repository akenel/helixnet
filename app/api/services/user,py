from unittest.mock import Base
import uuid
from typing import List, Optional

# Async SQLAlchemy imports: CRITICAL FIX
from sqlalchemy import select, delete
from sqlalchemy.ext.asyncio import AsyncSession # Use AsyncSession for non-blocking DB access
from sqlalchemy.engine import Result
from fastapi import HTTPException # For exceptions inside the service layer

# Import Pydantic schemas and DB Model
from app.schemas.user import UserCreate, UserUpdate
from app.db.models.user import User as UserModel # Import the SQLAlchemy Model

# ----------------------------------------------------
# Helper Functions (CRUD Operations)
# ------class JobSubmission(BaseModel):
class UserService(Base):
    pass    

# --- Temporary/Dummy Password Hashing (REPLACE ME) ---
def get_password_hash(password: str) -> str:
    """
    In a real application, this would use a secure library like passlib (e.g., bcrypt) 
    to hash the password securely.
    """
    # Simply return the password string prefixed, for development only.
    return f"hashed_{password}"
# --- End of Temporary Hashing ---


async def get_user_by_id(db: AsyncSession, user_id: UUID) -> Optional[UserModel]:
    """
    Retrieves a single user by their ID using an asynchronous session.
    """
    stmt = select(UserModel).where(UserModel.id == user_id)
    result: Result = await db.execute(stmt) # Use await db.execute()
    
    # scalar_one_or_none() gets the first result object or None
    return result.scalar_one_or_none()


async def get_user_by_email(db: AsyncSession, email: str) -> Optional[UserModel]:
    """
    Retrieves a single user by their email address using an asynchronous session.
    """
    stmt = select(UserModel).where(UserModel.email == email)
    result: Result = await db.execute(stmt) # Use await db.execute()
    return result.scalar_one_or_none()


async def get_users(db: AsyncSession, skip: int = 0, limit: int = 100) -> List[UserModel]:
    """
    Retrieves a list of users, supporting skip and limit for pagination.
    """
    # Order by creation date to get consistent results
    stmt = select(UserModel).offset(skip).limit(limit).order_by(UserModel.created_at)
    result: Result = await db.execute(stmt) # Use await db.execute()
    
    # scalars().all() gets a list of the model objects
    return result.scalars().all()


async def create_user(db: AsyncSession, user: UserCreate) -> UserModel:
    """
    Creates a new user model from the Pydantic schema and persists it asynchronously.
    """
    # 1. Check for existing user
    existing_user = await get_user_by_email(db, user.email)
    if existing_user:
        # Raise HTTP 400 Bad Request if the email is already registered
        raise HTTPException(status_code=400, detail="Email already registered.")
        
    # 2. Hash the password
    hashed_password = get_password_hash(user.password)
    
    # 3. Create the ORM model instance
    db_user = UserModel(
        email=user.email,
        hashed_password=hashed_password, 
        is_active=user.is_active
    )
    
    # 4. Add, commit, and refresh (all async)
    db.add(db_user)
    await db.commit() # Use await db.commit()
    await db.refresh(db_user) # Use await db.refresh()
    
    return db_user


async def update_user(db: AsyncSession, user_id: uuid.UUID, user_update: UserUpdate) -> Optional[UserModel]:
    """
    Updates an existing user's attributes asynchronously.
    """
    db_user = await get_user_by_id(db, user_id)
    
    if not db_user:
        return None

    update_data = user_update.model_dump(exclude_unset=True)
    
    for key, value in update_data.items():
        if key == "password" and value is not None:
            # Hash the new password before setting it
            setattr(db_user, "hashed_password", get_password_hash(value)) 
        elif value is not None:
            setattr(db_user, key, value)

    await db.commit()
    await db.refresh(db_user)
    
    return db_user


async def delete_user(db: AsyncSession, user_id: uuid.UUID) -> bool:
    """
    Deletes a user account by ID asynchronously.
    """
    stmt = delete(UserModel).where(UserModel.id == user_id)
    
    result = await db.execute(stmt)
    
    await db.commit()
    
    return result.rowcount > 0
# ----------------------------------------------------
# End of users.py
# ----------------------------------------------------