#  /code/docker-compose.yml

services:
  # The name of your development service (you may need to change this)
  # dev_container:
  #   # Use the image built from the Dockerfile above, or specify your image name
  #   build:
  #     context: .
  # #    dockerfile: .devcontainer/Dockerfile
    
  #   environment:
  #     - PYTHONPATH=/code
  #   container_name: helix-web-app # Cleaned up container name
  #   profiles:
  #     - core
  #     - app
  #   env_file:
  #     - .env

  #   # CRITICAL STEP: Mount the Docker socket from the host into the container
  #   # This allows the 'docker' CLI inside the container to talk to the host's daemon
  #   volumes:
  #     - /var/run/docker.sock:/var/run/docker.sock

  #   # If you need to map ports (e.g., for a running app)
  #   ports:
  #     - "3000:3000"
    
  #   # Keep the container running for development
  #   command: /bin/sh -c "while sleep 1000; do :; done"

  # -----------------------------------------------------
  # üõ°Ô∏è TRAEFIK: Edge Router with HTTPS Termination (mkcert)
  # -----------------------------------------------------
  # -----------------------------------------------------------------------------
# Traefik service block for docker-compose.yml
# Ensures Traefik loads all configurations (Entrypoints, TLS, Providers)
# from the static traefik.yml file, removing CLI conflicts.
# -----------------------------------------------------------------------------
  traefik:
    # Use a specific version for stability
    image: traefik:latest
    container_name: traefik
    profiles:
      - core
      - app
    # ‚ö†Ô∏è KIS FIX: Only load the configfile and ensure the dashboard is accessible.
    # All providers and entrypoints are now fully defined inside traefik.yml.
    command:
      - --configfile=/etc/traefik/traefik.yml
      - --api.dashboard=true
      - --api.insecure=true # Allows dashboard access via the web entrypoint if needed for testing
      - --log.level=DEBUG # Explicitly set DEBUG log level via CLI

    ports:
      - "80:80"     # Web entrypoint (HTTP, redirects to HTTPS)
      - "443:443"   # Websecure entrypoint (HTTPS)
    volumes:
      # CRITICAL: Access to the Docker socket for service discovery
      - /var/run/docker.sock:/var/run/docker.sock:ro
      # 1. Mount the static config file
      - ./traefik/traefik.yml:/etc/traefik/traefik.yml:ro
      # 2. Mount the dynamic config directory (contains dynamic.yml)
      - ./traefik/dynamic:/etc/traefik/dynamic:ro
      # 3. Mount the mkcert directory for TLS
      - ./traefik/certs:/etc/traefik/certs:ro
    networks:
      - helixnet_network

  # -----------------------------------------------------
  # üöÄ HELIX-WEB-APP: Your FastAPI Application (Main API)
  # -----------------------------------------------------
  helix-web-app:
    build: .
    environment:
      - PYTHONPATH=/code
    container_name: helix-web-app # Cleaned up container name
    profiles:
      - core
      - app
    env_file:
      - .env
    # No direct ports mapping! Traefik handles external access.
    # ports:
    #   - "8000:8000"
    volumes:
      - .:/code
    working_dir: /code
    # Command runs on internal port 8000 (HTTP)
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
    depends_on:
      - redis
      - rabbitmq
      - postgres
      - minio
    restart: unless-stopped
    networks:
      - helixnet_network
    # üí° Traefik Labels: Tells Traefik how to route done via dynamic,yaml instead
  # ----------------------------------------------------
  # CORE INFRASTRUCTURE SERVICES
  # ----------------------------------------------------
  redis:
    image: redis:7-alpine
    container_name: redis
    profiles: ["core"]
    command: redis-server --appendonly yes
    ports:
      - "6379:6379" # Kept for host development/inspection convenience
    volumes:
      - redis_data:/data
    restart: unless-stopped
    networks:
      - helixnet_network
    healthcheck:
        test: ["CMD", "redis-cli", "ping"]
        interval: 10s
        timeout: 5s
        retries: 5

  redis-ui:
    image: redislabs/redisinsight:latest
    container_name: redis-ui
    profiles:
      - core
    # üõë Ports removed: Access via https://redis-ui.helix.local
    # ports:
    #   - "5540:5540"
    expose:
      - "5540" # Internal port is 5540
    networks:
      - helixnet_network

  rabbitmq:
    image: rabbitmq:3-management-alpine
    container_name: rabbitmq
    profiles: ["core"]
    environment:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASS}
    ports:
      - "5672:5672"
      - "15672:15672" # Kept for host convenience (direct access to management console)
    restart: unless-stopped
    networks:
      - helixnet_network
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "ping"]

  postgres:
    image: postgres:15-alpine
    container_name: postgres
    profiles: ["core"]
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped
    networks:
      - helixnet_network
    ports:
      - "5432:5432" # Kept for host development/inspection convenience

  minio:
    image: minio/minio:latest
    container_name: minio
    profiles: ["core"]
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
    command: minio server /data --console-address ":9001"
    # üõë Ports changed: Internal ports only (9000 API, 9001 Console). Access via Traefik hostnames.
    # ports:
    #   - "9090:9000"
    #   - "9091:9001"
    expose:
      - "9000"
      - "9001"
    volumes:
      - minio_data:/data
    restart: unless-stopped
    networks:
      - helixnet_network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3  
  # ----------------------------------------------------
  # APPLICATION SERVICES
  # ----------------------------------------------------

  worker:
    build: .
    container_name: worker
    profiles: ["app", "worker", "core"]
    env_file:
      - .env
    volumes:
      - .:/code
    working_dir: /code
    command: ["celery", "-A", "app.tasks.celery_app:celery_app", "worker", "-l", "info", "--events"]
    depends_on:
      - rabbitmq
    restart: on-failure
    networks:
      - helixnet_network

  pgadmin:
    image: dpage/pgadmin4
    container_name: pgadmin
    profiles: ["core"]
    env_file:
      - .env
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD}
    # üõë Ports removed: Access via https://pgadmin.helix.local
    # ports:
    #   - "5050:80"
    expose:
      - "80" # Internal port is 80
    volumes:
      - pgadmin_data:/var/lib/pgadmin
    depends_on:
      - postgres
    restart: unless-stopped
    networks:
      - helixnet_network

  portainer:
    image: portainer/portainer-ce:latest
    container_name: portainer
    profiles: ["core"]
    command: -H unix:///var/run/docker.sock
    # üõë Ports removed: Access via https://portainer.helix.local
    # ports:
    #   - "9999:9443"
    expose:
      - "9000" # Portainer uses 9000 for HTTP API access internally
      - "9443" # Portainer's default HTTPS port (though Traefik handles the TLS)
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer_data:/data
    restart: unless-stopped
    networks:
      - helixnet_network

  beat:
    build: .
    container_name: beat
    profiles: ["core", "app"]
    env_file:
      - .env
    volumes:
      - .:/code
    working_dir: /code
    command: celery -A app.tasks.celery_app beat -l INFO 
    depends_on:
      - rabbitmq
      - worker
    restart: unless-stopped
    networks:
      - helixnet_network

  flower:
    image: mher/flower:master
    container_name: flower
    networks:
      - helixnet_network
    # Environment variables are highly recommended for the broker and result backend
    profiles: ["core", "app"]
    env_file:
      - .env
    environment:
      - CELERY_BROKER_URL=amqp://admin:admin@rabbitmq:5672//
      # Assuming your celery workers use Redis as the result backend
      - CELERY_RESULT_BACKEND=redis://redis:6379/0

    # Explicitly wait for RabbitMQ and Redis to be healthy to avoid 'Connection refused' errors on startup
    # This addresses the "kombu.exceptions.OperationalError: [Errno 111] Connection refused"
    depends_on:
      rabbitmq:
        condition: service_healthy
      redis:
        condition: service_healthy
  # Simplified command, relying on environment variables
    command: ["celery", "flower", "--address=0.0.0.0", "--port=5555"]
# ----------------------------------------------------
# NAMED VOLUMES
# ----------------------------------------------------
volumes:
  redis_data:
  postgres_data:
  minio_data:
  portainer_data:
  pgadmin_data:

# ----------------------------------------------------
# NETWORK
# ----------------------------------------------------
networks:
  helixnet_network:
    driver: bridge
